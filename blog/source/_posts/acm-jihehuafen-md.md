---
title: 集合划分
date: 2021-11-07 20:39:42
tags: ACM
---
## Problem
n个元素的集合{1,2,..., n }可以划分为若干个非空子集。例如，当n=4 时，集合{1，2，3，4}可以划分为15 个不同的非空子集如下：
```
{{1}，{2}，{3}，{4}}，

{{1，2}，{3}，{4}}，

{{1，3}，{2}，{4}}，

{{1，4}，{2}，{3}}，

{{2，3}，{1}，{4}}，

{{2，4}，{1}，{3}}，

{{3，4}，{1}，{2}}，

{{1，2}，{3，4}}，

{{1，3}，{2，4}}，

{{1，4}，{2，3}}，

{{1，2，3}，{4}}，

{{1，2，4}，{3}}，

{{1，3，4}，{2}}，

{{2，3，4}，{1}}，

{{1，2，3，4}}
```
给定正整数n，计算出n 个元素的集合{1,2,..., n }可以划分为多少个不同的非空子集。

## Input
多组输入(<=10组数据，读入以EOF结尾) 每组一行输入一个数字，n(0< n <=18)

## Output
每组输出一行结果。

## EX
```
4
```

```
15
```

## 思路
这道题一开始从整体上分析无从下手，但是不难体会到它是存在递推关系的，复杂问题可以将其分解为一步一步的小问题。因此可以从划分为一组开始讨论，每增加一个分组后划情况数会经历怎样的改变？（这个改变必须于上一个状态的划分数相关才可构成递推关系），

可以发现一种加法是将其中一个元素拿出，将该元素加入到n-1个元素的分组中，但是这样少考虑了该元素单独在一个组的情况，因此还需要加上这种情况的个数，也就是n-1个元素划分为m-1个set的个数。这样就构成了递推关系，可以递推到元素越来越少的情况，直到return1。

## Code
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int a[20];

int f(int i, int n){
    if(i == 1 || i >= n){
        return 1;
    }
    else{
        return f(i, n - 1)*i + f(i - 1, n - 1);
    }
}

int main(){
    int n;
    while(cin>>n){
        int ans = 0;
        for(int i = 1;i <= n;i++) { //对划分块数遍历
            ans += f(i, n);
        }
        cout<<ans<<endl;
    }
    return 0;
}
```